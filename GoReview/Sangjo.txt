1장. 여기는 적을게 없지만 이렇게 적장ㅎ_ㅎ
2장. 나는 한국인
3장. go는 이미 설치 했어.
4장. package. package는 header같은 것이다. fmt package는 print 함수들이 있는 것 같다.
5장. import를 한 번만 써도 되게 Go는 만들어 놓았다. 
6장. package에서 export 해 놓은 것을 import하면 사용할 수 있는데, Go에서는 첫 문자가 대문자로
    시작하면 그 package를 사용하는 곳에서 접근 할 수 있는 exported name이 됨.
7장. go에서 함수는 신기하게 parameter와 return 값의 type을 뒤에 씀.     
8장. go에서 parameter의 type이 같으면 마지막 것만 써도 된다.
9장. go에서는 함수가 여러개의 결과를 반환할 수 있다.
     func swap(x, y string) (string, string)
10장. 이름이 정해진 결과 - Named results. 
      결과에 이름을 붙이면 반환 값을 지정하지 않은 return 문장으로
      결과의 현재 값을 알아서 반환
      ex) func split(sum int) (x, y int){ //여기서 x와 y가 return 값으로 지정됨.
            x = sum* 4 / 9
            y = sum - x
            return          //자동으로 x와 y가 return됨.
          }
11장. 변수 선언을 위해서는 var라고 쓰고 뒤에 tpye을 적어준다.
12장. 변수 선언과 함께 변수 각각을 초기화 할 수 있는데
      초기화를 해서 변수 선언을 하면 type은 생략할 수 있음.
      var x, y, z int = 1, 2, 3 //여기서 굳이 int는 안적어도 됨
      var c, python, java = true, false, "no"!
13장. 함수 내에서  := 을 사용하면 변수 선언할 때 굳이 type을 안적어도 됨.
      하지만 중요한건 함수 밖에서는 := 선언을 사용할 수는 없음.
14장. 상수는 const 키워드와 함께 변수처럼 선언.
      상수는 char, string, bool, 숫자 타입으로 사용가능
15장. 숫자가 커지면 정밀하게 표현이 된다? e+29뭐 이런식으로 표현이 가능하다 이 것 같은데.
16장. go에서는 반복문이 for 밖에 없다(단 것도 while굳이 있어야 하나)
      소괄호가 필요없고 중괄호는 꼭 있어야 한다.
      for i := 0; i < 10; i++ {
        sum += i
      }
17장. for문에서 초기화화 변하는 것이 없고 조건만 있어도 된다.
18장. for문에서 조건문만 있으면 이 것이 while문! 
19장. for문에서 조건문까지 생략하면 무한 loop가 된다.
20장. if 문에서 조건 표현을 위한 소괄호는 생략하지만 실행을 위한 중괄호는 꼭 필요하다
21장. if 에서 조건문 앞에 짧은 문장을 실행할 수 있는데,
      이 짧은 문장에서 혹시 변수를 선언한다면 이 변수는 if 안쪽의 scope에서 
      실행이 가능하다.
      혹시나 하고 돌려봤는데 else에서도 사용 가능하다. 
22장. 오 21장에서 else는 안되나 했었는데 여기서 바로나오넹 ㅎ_ㅎ
23장. 연습. 
24장. 기본 자료형 bool, string, int, int8, int16, int32, int64
      byte == uint8, rune == int32, float32, float64, complex64, complex128
      그런데 복소수를 어떻게 표현한다는 거지? 그냥 계산만 한다는 건가?
25장. Structs. type 선언으로 struct의 이름을 지정할 수 있음.
      type Sangjo stuct {
        Amazing string
        Fantastic string
      }
26장. struct의 entity들은 .으로 접근
27장. Go에서는 pointer가 있는데 연산은 불가능함(아주 좋다!! 어딜 감히 메모리를 계산하려고)
      (아! 아닌가 메모리를 연산 불가능 한 점이 시스템 프로그래밍을 할 수 없는 이유가 되는 건가?
      
28장. struct literals
     {Name: value} 구문을 통해 field에 접근하여 할당할 수 있대.
     &을 사용하면 pointer 생성까지 가능~
29장. new 는 모든 field가 0이 할당된 포인터를 반환.
30장. slice는 배열의 값을 가지고, 길이를 가지고 있음. 배열이랑 좀 비슷한듯
      len 함수로 배열의 길이를 반환할 수 있다.
      []Type의 형태로 선언
31장. slice의 slicing. 슬라이스를 자를 수 있다. p[lo:hi]라고 하면 lo~hi-1까지의
      배열을 반환한다.
      그리고 p[:hi] 라고 하면 처음부터 hi - 1 까지.
      p[lo:]이라고 하면 lo부터 끝까지 배열을 반환한다.
32장. slice는  make함수로 만들 수 있다. 이렇게 생성된 slice는 0의 값을 
     할당한 배열을 생성하고 그 것을 refer함
     그리고 slice에서는 capacity의 개념이 있음.
     len과는 다른 len의 한계. 이 것은 make함수로 인자를 3개 넣으면 만들 수 있다.
     sl = make([]char, 10, 100)
     이라고 선언하면 len이 10이고 cap이 100임.
33장. slice의 zero value는 nil.
      nil slice의 길이와 최대 크기는 0
34장. for 반복문에서 range를 사용하면 slice를 순회할 수 있다.
      for i, v:= range pow {
      
      ...
      
      }
      라고 하면 i가 index, v가 value가 된다. 
      여기서 물론 i만 써도 된다. 
35장. 아 여기서 나오네!
      i만 쓰고 싶으면 for i := range pow 라고 하면되고
      value만 쓰고 싶으면
      for _, value := range pow라고 하면 됨
36장. 
37장. Maps은 값에 key를 기정.
      맵은 사용하기 전에 make를 반드시 명시해야함.
      make를 수행하지 않은 nil에는 값을 할당할 수 없음.
38장. Map literals. 리터럴이 구조체에다가 변수이름과 변수를 지정할 수 있음.
      Map literal은 반드시 key를 지정해야함. 
39장. 리터럴에서 타입명을 생략할 수도 있다고욤.
40장. 맵에 요서 삽입 or 수정 m[key] = elem
      값 가져요기 elem = m[key]
      요소 지우기 delete(m, key)
      키의 존재 여부 확인하기 elem, ok = m[key]
      여기서 ok는 값이 있으면 true, 없으면 false를 반환. 
41장. 
      
