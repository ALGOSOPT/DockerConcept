1장. Hello, 안녕
2장. 한국어
3장. go설치, tour 웹에서 진행
4장. 패키지 이름은 디렉토리 경로의 마지막 이름 사용 path/filepath => import filepath
5장. 소괄호()로 감싸서 import 할 수 있고 import 여러번 쓸수도 있다.
6장. 패키지 안에 대문자로 시작하는 메서드나 변수 상수는 외부에서 사용 가능한 export 속성이다.
7장. 함수는 매개변수를 가질수있다. x int 처럼 변수명 타입명 순서로 명시
8장. 여러개의 매개변수가 같은 타입일때 마지막 매개변수에만 타입 명시 x, y int
9장. 함수는 여러개의 결과를 반환할 수 있다.
10장. 함수 반환값에 이름을 부여하면 변수처럼 쓸 수 있다. 반환값을 지정하지 않고 return만 때려도 알아서 반환한다.
11장. 변수 var로 선언하고 뒤에 타입 명시 var x, y, z int
12장. 변수 선언 초기화 한번에 할 수 있다. 초기화 할때는 타입 생략가능
13장. := 사용시 var 과 명시적인 타입 생략 가능 but, 함수 밖에서는 쓸 수 없다.
14장. const 로 상수
15장. 타입을 지정 안하면 문맥에 따라 타입 가진다.
16장. for가 유일한 반복문이다. 소괄호() 쓰지 않고 중괄호{} 필수
17장. 전,후 처리 제외하고 조건만 표시 가능 like while
18장. 조건만 있는 for == while
19장. for {} => 무한루
20장. if문은 조건 표현시 ()를 사용하지 않음 but, {} 필수
21장. if 조건문 앞에 명령 실행 가능, 이때 선언된 변수는 if 안에서만 쓸 수 있다. => 짧은 명령문
22장. 짧은 명령문에서 선언 변수는 else 에서도 쓸 수 있다.
23장. for, if 활용해서 실습 진행 5번 도니까 같아졌다.
24장. int, uint 각각 8, 16, 32, 64비트로 사용가능, rune == int32
25장. struct는 필드들의 조합, type 선언으로 struct 이름 지정가 type Vertex struct
26장. 구조체 필드 . 으로 접근
27장. 포인터 있지만 연산은 불가, struct 변수는 포인터 이용 접근 가능, 이때 실제 값도 바뀐다.
28장. 구조체 리터럴 : 구조체의 필드에 값을 할당할때 {Name: value} 형식으로 할당할 수 있다. 필드 순서는 상관없음. & 사용시 포인터 리터럴 생성가능
29장. new : 모든 필드가 0, nil 이 할당된 구조체 포인터 반환
30장. 슬라이스: 배열값 point, 길이 가짐 p := []int{2, 3, 4} / len(p)
31장. p[low:high] 를 통해 자를 수 있다. 배열 복사 가능(같은 배열을 가리킴)
32장. make를 통해 슬라이스 생성 a := make([]int, 4, 10) -> 크기가 4이고 최대크기 10인 0으로 채워진 슬라이스 생성
      cap(a) : 명령어를 통해 최대용량 확인가능
33장. 빈슬라이스는 == nill / 길이와 최대크기 0
34장. for => range 사용시 슬라이스, 맵 순회 for i, v := range pow {}
35장. _ : 인덱스나 값 무시
 for 인덱스, 값  := range pow {} : 값은 생략 가능, 인덱스는 _ 로 무시
36장.
 func Pic(dx, dy int) [][]uint8 {
    a := make([][]uint8, dy)
    b := make([]uint8, dx)
    for i := range b {
    	b[i] = uint8(i)
    }
    for i := range a {
        a[i] = b
    }
    return a
}
37장. map : key, value 형태, make를 이용해 반드시 생성해야함 m = make(map[string]Vertex)
      m["jjs"] = Vertex{11.0, 14.0}
38장. 맵리터럴 : {key: value} 형식으로 값 할당 가능, but key를 반드시 지정해야한다.
39장. 선언할때 쓴 타입명과 같은 타입의 값을 할당한다면, 타입명 생략 가능
40장.
    m["jjs"] = 1114
    jisu := m["jjs"]
    fmt.Println(jisu)
    s, isExist := m["jjs"]
    fmt.Println(s, isExist)

    delete(m, "jjs")

    s, isExist = m["jjs"]
    fmt.Println(s, isExist)
41장.
func WordCount(s string) map[string]int {

    a := make(map[string]int)
    var str []string
    str = strings.Fields(s)

    for _, v:= range str {
        a[v] += 1

    }
    //fmt.Println(str)
    return a
}
42장. 리턴값이 있는 함수는 함수의 인자값이 될 수 있다.
43장. 함수는 클로저이다. 클로저 : 내부함수가 외부함수의 context에 접근할 수 있는 것
44장. 피보나치 클로져
func fibonacci() func() int {
    a := 1
    b := 1
    return func() int {
        a, b = b, a+b
        return a
    }
}
